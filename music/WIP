#! /bin/bash
set -eo pipefail
IFS="$(printf '\n\t')"
cd "$(dirname "${BASH_SOURCE[0]}")"

#set -u

# ---- Definitions ----
# DB - sqlite db
# CSV - the CSV list of all the songs and what playlists they are in
# zip - From exportify, contains individual CSVs of the playlists
# PlaylistCSVs - the files inside the zip

DB=songs.db
CSV=songs.csv
FOLDER=playlists

if (type -a md5 &>/dev/null); then
	md5String() {
		md5 -qs "$1"
	}
	md5File() {
		md5 -q "$1"
	}
else
	md5String() {
		echo -n "$1" | md5sum | cut -f 1 -d ' '
	}
	md5File() {
		echo Not yet implemented.
		exit 1
	}
fi
if [ 098f6bcd4621d373cade4e832627b4f6 != $(md5String test) ] || [ 098f6bcd4621d373cade4e832627b4f6 != $(md5File <(echo -n test)) ]; then
	echo Hashing test failed! Received string $(md5String test) and file hash $(md5File <(echo -n test))
	exit 1
fi

fixUnescapedQuotesInCsv() {
	perl -n -i -e 's/(?<!",)"(?!,")/""/g; s/^""/"/g; s/""$/"/g; print;' "$1"
}

createDb() {
	sqlite3 "$DB" <<-EOF
	CREATE TABLE songs (
		startTime TEXT,
		endTime TEXT,
		extraSearchTerm TEXT,
		shouldDownload TEXT,
		youtubeTitle TEXT,
		playlist TEXT,
		title TEXT,
		artist TEXT,
		album TEXT,
		filename TEXT,
		spotifyUri TEXT,
		infoHash TEXT,
		fileHash TEXT,
		youtubeId TEXT
	);
	EOF
}

importPlaylistCsvsToDb() {
	filename=$(basename -- "$1")
	playlist="${filename%.*}"

	sqlite3 "$DB" <<-EOF
	.mode csv
	.import "$1" import

	INSERT INTO songs 
		(playlist, filename, youtubeId, youtubeTitle, spotifyUri, title, artist, album, startTime, endTime, extraSearchTerm, shouldDownload, infoHash, fileHash)
	SELECT "$playlist" AS playlist, "" AS filename, "" AS youtubeId, "" AS youtubeTitle, "Spotify URI", "Track Name", "Artist Name", "Album Name", "" AS startTime, "" AS endTime, "" AS extraSearchTerm, 1 AS shouldDownload, "" AS infoHash, "" AS fileHash
	FROM import;

	DROP TABLE import;
	EOF
}

dbToCsv() {
	sqlite3 "$DB" <<-EOF
	.headers on
	.mode csv
	.output "$CSV"
	SELECT * FROM songs;
	EOF

	rm "$DB"
}

createCsvFromZip() {
	createDb
	tempFolder=$(mktemp -d)
	echo "Using temp dir $tempFolder"
	unzip "$1" -d "$tempFolder"
	for filepath in $(ls "$tempFolder"/*.csv); do
		fixUnescapedQuotesInCsv "$filepath"
		importPlaylistCsvsToDb "$filepath"
	done
	dbToCsv
}

csvToDb() {
	sqlite3 "$DB" <<-EOF
	.mode csv
	.import "$CSV" songs
	EOF

	rm "$CSV"
	trap dbToCsv EXIT
}

downloadFromDb() {
	mkdir -p "$FOLDER"
	for id in $(sqlite3 "$DB" "SELECT rowid FROM songs;"); do
		downloadSongFromDbWithId $id
	done
}

downloadFromCsv() {
	csvToDb
	downloadFromDb
}

whereIdIsSelectColumn() {
	sqlite3 "$DB" "SELECT \"$2\" FROM songs WHERE rowid = \"$1\";"
}

whereIdIsUpdateColumn() {
	sqlite3 "$DB" "UPDATE songs SET \"$2\"='$3' WHERE rowid = \"$1\";"
}

calculateInfoHashWithId() {
	md5String "$(sqlite3 "$DB" "SELECT playlist, youtubeId, spotifyUri, title, artist, album, startTime, endTime, extraSearchTerm, shouldDownload FROM songs WHERE rowid = \"$1\";")"
}

downloadSongFromDbWithId() {
	for column in playlist filename youtubeId youtubeTitle spotifyUri title artist album startTime endTime extraSearchTerm shouldDownload infoHash fileHash; do
		declare $column="$(whereIdIsSelectColumn $1 $column)"
	done
	idTitle="${title//\'/}"
	idArtist="${artist//\'/}"
	filePath="$FOLDER/$playlist"
	mkdir -p "$filePath"

	if [ "$infoHash" != "$(calculateInfoHashWithId $1)" ]; then
		# Check if infohash is current - if not, redownload and save data
		echo "Downloading and updating data for title: '$idTitle' and artist: '$idArtist'"

		searchTerm="${title//:/} ${artist//:/} $extraSearchTerm"
		echo "Searching for: '$searchTerm'"
		downloadYoutubeAndExport_dlFilename_dlYoutubeId --search "$searchTerm"

		whereIdIsUpdateColumn $1 youtubeId "$dlYoutubeId"
		whereIdIsUpdateColumn $1 youtubeTitle "${dlFilename%.mp3}"
		whereIdIsUpdateColumn $1 fileHash "$(md5File "$dlFilename")"

		infoHash="$(calculateInfoHashWithId $1)"
		whereIdIsUpdateColumn $1 infoHash "$infoHash"

		filename="${dlFilename%.mp3}-${infoHash:0:5}.mp3"
		whereIdIsUpdateColumn $1 filename "$filename"
		mv "$dlFilename" "$filePath/$filename"

	elif [ ! -f "$filePath/$filename" ] && [ "$fileHash" != "$(md5File "$filePath/$filename")" ]; then
		# Check if file exists and filehash is current - if not, redownload from data
		echo "Redownloading from saved data - title: '$idTitle' and artist: '$idArtist'"
		downloadYoutubeAndExport_dlFilename_dlYoutubeId --id "$youtubeId"
		mv "$dlFilename" "$filePath/$filename"

	else
		# File and info are up-to-date
		echo "File up-to-date - title: '$idTitle' and artist: '$idArtist'"
	fi
}

downloadYoutubeAndExport_dlFilename_dlYoutubeId() {
	downloadYoutube() {
		if [ "$1" == "--search" ]; then
			youtube-dl --format bestaudio --audio-format mp3 --extract-audio --postprocessor-args "-metadata title='$idTitle' -metadata artist='$idArtist'" --output '%(title)s.%(ext)s' --default-search ytsearch "$2" 
		elif [ "$1" == "--id" ]; then
			youtube-dl --format bestaudio --audio-format mp3 --extract-audio --postprocessor-args "-metadata title='$idTitle' -metadata artist='$idArtist'" --output '%(title)s.%(ext)s' "$2" 
		fi
	}

	set_dlFilename_dlYoutubeId_FromData() {
		while IFS=' ' read -r tool step info; do
			if [ "$tool" == "[ffmpeg]" ] && [ "$step" == "Destination:" ]; then
				#newFilename=$( echo "$filename" | sed -r -e 's/ ?\(?lyrics\)? ?/ /i' -e 's/^ *//;s/ *\.mp3$/.mp3/' )
				#mv "$filename" "$newFilename"
				dlFilename="$info"
				echo "Saved file: '$dlFilename'"
			elif [ "$tool" == "[youtube]" ] && [ "$info" == "Downloading webpage" ]; then
				dlYoutubeId=${step%:}
				echo "From Youtube Id: $dlYoutubeId"
			fi
		done <<< "$1"
	}

	sanitizeMoveAndExport_dlFilename() {
		filename="${1//\'/}"
		mv "$1" "$filename"
	}

	downloadedMetadata="$(downloadYoutube "$@")"
	set_dlFilename_dlYoutubeId_FromData "$downloadedMetadata"
	sanitizeMoveAndExport_dlFilename "$dlFilename"
}

SOURCE=csv
OUTPUT=csv
POSITIONAL=()
while
    key="$1"
    case $key in
		--source)
			SOURCE="$2"
			shift; shift ;;
        --output)
            OUTPUT="$2"
            shift; shift ;;
        -*)
            echo "Unknown option: $1"
            exit 1 ;;
        *)
            POSITIONAL+=("$1")
            shift ;;
    esac
    [[ $# -gt 0 ]]
do true; done
set -- "${POSITIONAL[@]}"

case "$SOURCE" in
	zip)
		createCsvFromZip "$1"
		;;
	gdrive)
		downloadCsvFromGdrive
		;;
	csv)
		;;
	*)
		echo Not a valid source
		exit 1
		;;
esac

case "$OUTPUT" in
	sql|sqlite|sqlite3)
		;;
	csv)
		;;
esac

case "$1" in
	download)
		shift
		downloadFromCsv
		;;
	*)
		echo Please specify: download
		exit 1 ;;
esac

# ==== Cases ====
# CSV doesn't exist
# Song added to spotify
# Playlist added to spotify
# Song added to CSV
# Youtube link changed
# Start or end time changed
